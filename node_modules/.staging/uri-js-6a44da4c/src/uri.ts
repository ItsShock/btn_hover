/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */

/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */

import URI_PROTOCOL from "./regexps-uri";
import IRI_PROTOCOL from "./regexps-iri";
import punycode from "punycode";
import { toUpperCase, typeOf, assign } from "./util";

export interface URIComponents {
	scheme?:string;
	userinfo?:string;
	host?:string;
	port?:number|string;
	path?:string;
	query?:string;
	fragment?:string;
	reference?:string;
	error?:string;
}

export interface URIOptions {
	scheme?:string;
	reference?:string;
	tolerant?:boolean;
	absolutePath?:boolean;
	iri?:boolean;
	unicodeSupport?:boolean;
	domainHost?:boolean;
}

export interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {
	scheme:string;
	parse(components:ParentComponents, options:Options):Components;
	serialize(components:Components, options:Options):ParentComponents;
	unicodeSupport?:boolean;
	domainHost?:boolean;
	absolutePath?:boolean;
}

export interface URIRegExps {
	NOT_SCHEME : RegExp,
	NOT_USERINFO : RegExp,
	NOT_HOST : RegExp,
	NOT_PATH : RegExp,
	NOT_PATH_NOSCHEME : RegExp,
	NOT_QUERY : RegExp,
	NOT_FRAGMENT : RegExp,
	ESCAPE : RegExp,
	UNRESERVED : RegExp,
	OTHER_CHARS : RegExp,
	PCT_ENCODED : RegExp,
	IPV4ADDRESS : RegExp,
	IPV6ADDRESS : RegExp,
}

export const SCHEMES:{[scheme:string]:URISchemeHandler} = {};

export function pctEncChar(chr:string):string {
	const c = chr.charCodeAt(0);
	let e:string;

	if (c < 16) e = "%0" + c.toString(16).toUpperCase();
	else if (c < 128) e = "%" + c.toString(16).toUpperCase();
	else if (c < 2048) e = "%" + ((c >> 6) | 192).toString(16).toUpperCase() + "%" + ((c & 63) | 128).toString(16).toUpperCase();
	else e = "%" + ((c >> 12) | 224).toString(16).toUpperCase() + "%" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + "%" + ((c & 63) | 128).toString(16).toUpperCase();

	return e;
}

export function pctDecChars(str:string):string {
	let newStr = "";
	let i = 0;
	const il = str.length;

	while (i < il) {
		const c = parseInt(str.substr(i + 1, 2), 16);

		if (c < 128) {
			newStr += String.fromCharCode(c);
			i += 3;
		}
		else if (c >= 194 && c < 224) {
			if ((il - i) >= 6) {
				const c2 = parseInt(str.substr(i + 4, 2), 16);
				newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
			} else {
				newStr += str.substr(i, 6);
			}
			i += 6;
		}
		else if (c >= 224) {
			if ((il - i) >= 9) {
				const c2 = parseInt(str.substr(i + 4, 2), 16);
				const c3 = parseInt(str.substr(i + 7, 2), 16);
				newStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
			} else {
				newStr += str.substr(i, 9);
			}
			i += 9;
		}
		else {
			newStr += str.substr(i, 3);
			i += 3;
		}
	}

	return newStr;
}

function _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {
	function decodeUnreserved(str:string):string {
		const decStr = pctDecChars(str);
		return (!decStr.match(protocol.UNRESERVED) ? str : decStr);
	}

	if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
	if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);

	return components;
};

function _stripLeadingZeros(str:string):string {
	return str.replace(/^0*(.*)/, "$1") || "0";
}

function _normalizeIPv4(host:string, protocol:URIRegExps):string {
	const matches = host.match(protocol.IPV4ADDRESS) || [];
	const [, address] = matches;
	
	if (address) {
		return address.split(".").map(_stripLeadingZeros).join(".");
	} else {
		return host;
	}
}

function _normalizeIPv6(host:string, protocol:URIRegExps):string {
	const matches = host.match(protocol.IPV6ADDRESS) || [];
	const [, address, zone] = matches;

	if (address) {
		const [last, first] = address.toLowerCase().split('::').reverse();
		const firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
		const lastFields = last.split(":").map(_stripLeadingZeros);
		const isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
		const fieldCount = isLastFieldIPv4Address ? 7 : 8;
		const lastFieldsStart = lastFields.length - fieldCount;
		const fields = Array<string>(fieldCount);

		for (let x = 0; x < fieldCount; ++x) {
			fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
		}

		if (isLastFieldIPv4Address) {
			fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
		}

		const allZeroFields = fields.reduce<Array<{index:number,length:number}>>((acc, field, index) => {
			if (!field || field === "0") {
				const lastLongest = acc[acc.length - 1];
				if (lastLongest && lastLongest.index + lastLongest.length === index) {
					lastLongest.length++;
				} else {
					acc.push({ index, length : 1 });
				}
			}
			return acc;
		}, []);

		const longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];

		let newHost:string;
		if (longestZeroFields && longestZeroFields.length > 1) {
			const newFirst = fields.slice(0, longestZeroFields.index) ;
			const newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
			newHost = newFirst.join(":") + "::" + newLast.join(":");
		} else {
			newHost = fields.join(":");
		}

		if (zone) {
			newHost += "%" + zone;
		}

		return newHost;
	} else {
		return host;
	}
}

const URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
const NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>("").match(/(){0}/))[1] === undefined;

export function parse(uriString:string, options:URIOptions = {}):URIComponents {
	const components:URIComponents = {};
	const protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);

	if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;

	const matches = uriString.match(URI_PARSE);

	if (matches) {
		if (NO_MATCH_IS_UNDEFINED) {
			//store each component
			components.scheme = matches[1];
			components.userinfo = matches[3];
			components.host = matches[4];
			components.port = parseInt(matches[5], 10);
			components.path = matches[6] || "";
			components.query = matches[7];
			components.fragment = matches[8];

			//fix port number
			if (isNaN(components.port)) {
				components.port = matches[5];
			}
		} else {  //IE FIX for improper RegExp matching
			//store each component
			components.scheme = matches[1] || undefined;
			components.userinfo = (uriString.indexOf("@") !== -1 ? matches[3] : undefined);
			components.host = (uriString.indexOf("//") !== -1 ? matches[4] : undefined);
			components.port = parseInt(matches[5], 10);
			components.path = matches[6] || "";
			components.query = (uriString.indexOf("?") !== -1 ? matches[7] : undefined);
			components.fragment = (uriString.indexOf("#") !== -1 ? matches[8] : undefined);

			//fix port number
			if (isNaN(components.port)) {
				components.port = (uriString.match(/\/\/(?